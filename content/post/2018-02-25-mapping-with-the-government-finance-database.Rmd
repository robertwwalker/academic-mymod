---
title: Mapping with the Government Finance Database
author: Robert W. Walker
date: '2018-02-25'
slug: mapping-with-the-government-finance-database
categories:
  - R
  - Maps
  - Public Finance
tags:
  - Maps
  - R
---

# The Government Finance Database

Some of my colleagues (Kawika Pierson, Mike Hand, and Fred Thompson) have put together a convenient access point for the [Government Finance data](http://willamette.edu/mba/research_impact/public_datasets/index.html) available from the Census.  I want to build some maps from their project with extensible code and functions.  The overall dataset is enormous.  I have downloaded the whole thing and filtered out the states.  It seems that `read.csv` works better than `read_csv` for this task.  A link to the .zip version for states is [here](http://www.willamette.edu/~kpierson/TheGovernmentFinanceDatabase_StateData.zip).

The code for doing it all is here; I did not run it specifically for the post.  You have to download their data directly as a .zip and unzip.

```
library(dplyr)
GFD <- read.csv("~/Documents/The Government Finance Database_All Data.csv")
State.Data <- GFD %>% filter(Type_Code==0)
rm(GFD)
```

# The basic maps

*choroplethr* makes the process of mapping data a bit too easy.  It is locked down but it works very well.  What I will require is a simple function to cleave off a particular year, the state name, and whatever series of data I wish to make; I will need to store the latter two with the name `region` for the state name and `value` for whatever data we wish to plot.  Why?  That is the way that *state_choropleth()* is designed.  Let me load the packages and have a look at the names.  It is some identifiers including the *region* that I will use and the definitions of the states as polygons to plot.

```{r MapsDataBase, warning=FALSE, message=FALSE}
library(choroplethr)
library(choroplethrMaps)
data(state.map)
names(state.map)
```

```{r LData, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE}
load("~/GFDatabaseStates.RData")
```

# Putting them together

Let's see what we can do.  The first step is that the state name conventions are inconsistent, though the FIPS codes, thankfully, do not change.  I will convert them to strings, to drop the unused levels of the factors from import, and replace the state delineated names with a single standard name.  The second relevant selector is going to be the year, *Year4*.  Finally, I have to choose something to put in values.  Let me try total revenue per capita in year 2015.  *dplyr* is so neat that this can be done in only five lines.  Define and name the object; filter by the year; mutate the data into the two things I need; select them off.

```{r DataBackground, message=FALSE,warning=FALSE}
library(dplyr)
library(tidyverse)
State.Data$Name <- as.character(State.Data$Name)
State.Data$NameFixed <- gsub(" STATE GOVT","",State.Data$Name)
State.Data$NameFLower <- tolower(State.Data$NameFixed)
# Clean up the names and store the cleaned result
my.GFD.2015 <- State.Data %>% 
  filter(Year4==2015) %>%
  mutate(value = Total_Taxes / Population, region = NameFLower) %>%
  select(region, value)
my.GFD.2015
```

That is exactly the data that I need.  Finally, add a title and continuous color scheming.

```{r MapTheData}
state_choropleth(my.GFD.2015, title="Total Taxes per capita", num_colors=1)
```

That's far too easy.  Total taxes, which I have not bothered to look up, appear to contain some unexpected details.  What else can be done with it?  The final code chunk does it all.  To calculate a new map, just change the name of the thing per capitized.  What data are available?  See below....

```{r NamesD}
names(State.Data)
```

### Revenues per capita

Change it up with a recalcalculation of the data and a new map.

```{r Finished2}
my.GFD.2015 <- State.Data %>% 
  filter(Year4==2015) %>%
  mutate(value = Total_Revenue / Population, region = NameFLower) %>%
  select(region, value)
state_choropleth(my.GFD.2015, title="Total Revenues per capita", num_colors=1)
```


